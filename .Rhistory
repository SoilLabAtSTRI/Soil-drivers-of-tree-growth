if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste( basePath, "/R/Github/Soil-drivers-of-tree-growth/", sep="" )
source( paste( baseRSourcePath, "Source/Env.R", sep="" ) )
source( paste( mainSourcePath, "packages.R", sep="" ) )
basePath
paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
exists("PathsAndEnvironmentInitialised")
if ( !exists("PathsAndEnvironmentInitialised") ) {
if ( !exists("baseRSourcePath") ) {
# Set up the variable baseRSourcePath to the correct path
# e.g.:
# baseRSourcePath <- Sys.getenv("R_USER")
}
source( paste( baseRSourcePath, "Source/Env.R", sep="" ) )
}
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
attach( paste0( rawDataPath, "CTFSRPackage.rdata" ) )
exists("rawDataPath")
source( paste0( mainSourcePath, "Reformat raw data.R" ) )
source( paste0( mainSourcePath, "Growth functions.R" ) )
source( paste0( mainSourcePath, "Shade estimation.R" ) )
censusPath1 <- paste0( growthDataPath, "BCI tree census 6.rds" )
censusPath2 <- paste0( growthDataPath, "BCI tree census 7.rds" )
sppPath <- paste0( growthDataPath, "bci_spptable.rds" )
topoPath <- paste0( growthDataPath, "BCI topography.rds" )
if ( !file.exists( paste0( growthDataPath, "dbhgrowth-tree censuses 6-7.rds" ) ) ) {
# Calculate the DBH growth. Note that for the data from conditdatacenter the
# tables do not have the pom column, so pomCut refers to homCut.
# Because buttressed trees might have substantial hom differences, and the
# buttressing is being corrected for, the homCut is relaxed somewhat, 0.5
# vs 0.05
df <- GetDBHGrowthEx( censusPath1, censusPath2, speciesPath=sppPath,
topoPath=topoPath,
imposeMinGrowth=0.1, minimumNumber=10,
pomCut=0.5, gridSize=10 )
# Set the dbh per growth interval to be the midpoint
df$dbh <- (df$dbh1 + df$dbh2) / 2
# Clean up the table - remove unnecessary columns
df <- df[ , c("binX", "binY", "gx", "gy", "tag", "sp", "Latin",
"incgr", "convex", "slope", "dbh") ]
saveRDS( df, paste0( growthDataPath, "dbhgrowth-tree censuses 6-7.rds" ) )
}
file.exists( paste0( growthDataPath, "DBH growth data with light-2005-2010.rds" ) )
df <- GetDBHGrowthEx( censusPath1, censusPath2, speciesPath=sppPath,
topoPath=topoPath,
imposeMinGrowth=0.1, minimumNumber=0,
pomCut=2, gridSize=10 )
# Set the dbh per growth interval to be the midpoint
df$dbh <- (df$dbh1 + df$dbh2) / 2
# Calculate the tree heights
df.ssa <- read.csv( paste0( rawDataPath, "BCI species-specific allometries.csv" ) )
df$height <- taper.H( df, df.ssa=df.ssa )
listCanopy <- GetCanopyCensuses()
str(listCanopy)
censusSubset <- 4:6
for ( i in censusSubset ) {
start <- proc.time()
s <- paste0( "shade", names(listCanopy)[i] )
l <- paste0( "light", names(listCanopy)[i] )
print( s )
df[,s] <- GetShadingIndex( df, listCanopy[[i]] )
# Convert the shade into a light value using the formula from Appendix S1 of
# Ruger et al. 2009
df[,l] <- exp(-0.01351 - 0.08043*df[,s] - 0.00315*df[,s]^2)
print( proc.time() - start )
saveRDS( df[,c("tag",s,l)], paste0( growthDataPath, "Shade-light-", names(listCanopy)[i], ".rds" ) )
}
library(nlme)
source( paste( mainSourcePath, "Utilities.R", sep="") )
df <- GetGrowthModelData()  # From Utilities.R
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + pH + l.dbh + l.light + l.slope + convex
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
listRE <- list( "~ l.dbh + l.light + Mn3 + M3P + K3 | sp",
"~ l.dbh + l.light + Mn3 + K3 | sp",
"~ l.dbh + l.light + Mn3 + M3P | sp",
"~ l.dbh + l.light + M3P + K3 | sp",
"~ l.dbh + l.light + Mn3 | sp",
"~ l.dbh + l.light + K3 | sp",
"~ l.dbh + l.light + M3P | sp",
"~ l.dbh + l.light | sp")
# Test each RE structure. REML must be used
listMods <- vector( mode="list", length=length(listRE) )
i = length(listRE)
startTime <- proc.time()
randomEffect <- as.formula( listRE[[i]] )
listMods[[i]] <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="REML", control=modCtrl,
weights=varExp() )
print( paste( "Time for", listRE[[i]], ":" ) )
print( proc.time() - startTime )
library( nlme )
library( car )
source( paste( mainSourcePath, "Utilities.R", sep="") )
df <- GetGrowthModelData()  # From Utilities.R
# The models need to be fitted with ML since the fixed effects
# are being changed in each step of the process
# The "optimal" random effects included the soil vars Mn and P.
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + pH + l.dbh + l.light + l.slope + convex
randomEffect <- ~ l.dbh + l.light + Mn3 + M3P | sp
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + l.dbh + l.light
startTime <- proc.time()
mod.c.reml <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="REML", control=modCtrl,
weights=varExp() )
print( proc.time() - startTime )
summary(mod.c.reml)
# Save the model? If not, comment out
saveRDS( mod.c.reml, paste0( dataPath, "Selected growth model.rds" ) )
write.csv( coef( mod.c.reml ), paste0( dataPath, "BCI growth model Coefs-light,dbh,Mn,P-RE 2010 soil.csv" ) )
library(nlme)
library(MuMIn)
options(na.action = "na.fail")
source( paste0( mainSourcePath, "Utilities.R" ) )
df <- GetGrowthModelData()  # From Utilities.R
# The best random effect structure is found by "Find best model random effects.R"
# Since the "best" RE chosen would not have been the same depending on whether
# the AIC or BIC was used to decide, several different RE structures are tested
# to ascertain any differences based on differing RE structures.
# Model for the model averaging with the "best" RE, and the full fixed effects
fixedEffect <- log(incgr) ~ l.dbh + l.light + Mn3 + M3P + Al3 + K3 + pH + l.slope + convex
randomEffect <- ~ l.dbh + l.light + Mn3 + M3P | sp
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
startTime <- proc.time()
mod.full <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="ML", control=modCtrl,
weights=varExp() )
print( proc.time() - startTime )
startTime <- proc.time()
mods.ldmp.AIC <- dredge( mod.full, subset=l.dbh & l.light & Mn3 & M3P,
beta="none", extra=c(r2.Xu), trace=T )
source( paste0( mainSourcePath, "Legume Growth Analysis.R" ) )
GetModelSoilTopoCorrelations()
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
mainSourcePath
source( paste0( mainSourcePath, "Utilities.R" ) )
mod <- readRDS( paste0( dataPath, "Selected growth model.rds" ) )
df.coef <- coef( mod )
df.aff <- data.frame( sp=row.names( df.coefs ) )
df.aff <- data.frame( sp=row.names( df.coef ) )
df.aff <- cbind( df.aff, df.coef[df.aff$sp,] )
names(mod$data)
print( GetModelSoilTopoCorrelations() )
df.latin <- readRDS( paste0( growthDataPath, "bci_spptable.rds" ) )
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
df.latin <- readRDS( paste0( growthDataPath, "bci_spptable.rds" ) )
names(df.latin)
df.coef <- coef( mod )
df.aff <- data.frame( sp=row.names( df.coef ) )
df.aff <- cbind( df.aff, df.coef[df.aff$sp,] )
df.aff <- merge( df.aff, df.latin[, 1:2], by="sp")
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
if ( !exists("PathsAndEnvironmentInitialised") ) {
if ( !exists("baseRSourcePath") ) {
# Set up the variable baseRSourcePath to the correct path
# e.g.:
# baseRSourcePath <- Sys.getenv("R_USER")
}
source( paste0( baseRSourcePath, "Source/Env.R" ) )
}
# Set up directories to reference the raw and the reformatted and created growth data
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
source( paste0( mainSourcePath, "Utilities.R" ) )
mod <- readRDS( paste0( dataPath, "Selected growth model.rds" ) )
df.latin <- readRDS( paste0( growthDataPath, "bci_spptable.rds" ) )
# The random effects coefficients in this model are for four REs: light, DBH, Mn and P
df.coef <- coef( mod )
df.aff <- data.frame( sp=row.names( df.coef ) )
df.aff <- cbind( df.aff, df.coef[df.aff$sp,] )
df.aff <- merge( df.aff, df.latin[, 1:2], by="sp")
df.aff <- merge( df.aff, GetDistributionAffinities(df.aff$Latin), by.x="Latin", by.y="sp" )
head(df.aff)
names(df.aff[, c(4:6,11:13,16) ])
pairs(df.aff[, c(4:6,12,15,16) ]) # no correlation in affinites
cor(df.aff[, c(4:6,12,15,16) ])
cor(df.aff[, c(4:7,12,15,16) ])
cor(df.aff[, c(4:5,12,15,16) ])
summary(lm( M3P ~ P, data=df.ff))
summary(lm( M3P ~ P, data=df.aff))
.112^2
names(df.aff)
pairs(df.aff[, c("M3P", "P", "Mn3", "Al") ]) # no correlation in affinites
cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])
mod.P <- lm( M3P ~ P, data=df.aff)
plot( mod.P )
summary( mod.P )  # No relationship for P
str(cor(df.aff[, c("M3P", "P", "Mn3", "Al") ]))
cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])["M3P", "P"]
cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])["M3P", "P"]^2
print( paste( "P affinity correlation with P response: ", affCor["M3P", "P"]^2) )  # 0.0126
affCor <- cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])
print( paste( "P affinity correlation with P response: ", affCor["M3P", "P"]^2) )  # 0.0126
print( paste( "P affinity correlation R2 with P response: ", affCor["M3P", "P"]^2) )  # 0.0126
source( paste0( mainSourcePath, "Correlations Analyses.R" ) )
