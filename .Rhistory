source( paste0( mainSourcePath, "Growth functions.R" ) )
source( paste0( mainSourcePath, "Shade estimation.R" ) )
censusPath1 <- paste0( growthDataPath, "BCI tree census 6.rds" )
censusPath2 <- paste0( growthDataPath, "BCI tree census 7.rds" )
sppPath <- paste0( growthDataPath, "bci_spptable.rds" )
topoPath <- paste0( growthDataPath, "BCI topography.rds" )
if ( !file.exists( paste0( growthDataPath, "dbhgrowth-tree censuses 6-7.rds" ) ) ) {
# Calculate the DBH growth. Note that for the data from conditdatacenter the
# tables do not have the pom column, so pomCut refers to homCut.
# Because buttressed trees might have substantial hom differences, and the
# buttressing is being corrected for, the homCut is relaxed somewhat, 0.5
# vs 0.05
df <- GetDBHGrowthEx( censusPath1, censusPath2, speciesPath=sppPath,
topoPath=topoPath,
imposeMinGrowth=0.1, minimumNumber=10,
pomCut=0.5, gridSize=10 )
# Set the dbh per growth interval to be the midpoint
df$dbh <- (df$dbh1 + df$dbh2) / 2
# Clean up the table - remove unnecessary columns
df <- df[ , c("binX", "binY", "gx", "gy", "tag", "sp", "Latin",
"incgr", "convex", "slope", "dbh") ]
saveRDS( df, paste0( growthDataPath, "dbhgrowth-tree censuses 6-7.rds" ) )
}
file.exists( paste0( growthDataPath, "DBH growth data with light-2005-2010.rds" ) )
df <- GetDBHGrowthEx( censusPath1, censusPath2, speciesPath=sppPath,
topoPath=topoPath,
imposeMinGrowth=0.1, minimumNumber=0,
pomCut=2, gridSize=10 )
# Set the dbh per growth interval to be the midpoint
df$dbh <- (df$dbh1 + df$dbh2) / 2
# Calculate the tree heights
df.ssa <- read.csv( paste0( rawDataPath, "BCI species-specific allometries.csv" ) )
df$height <- taper.H( df, df.ssa=df.ssa )
listCanopy <- GetCanopyCensuses()
str(listCanopy)
censusSubset <- 4:6
for ( i in censusSubset ) {
start <- proc.time()
s <- paste0( "shade", names(listCanopy)[i] )
l <- paste0( "light", names(listCanopy)[i] )
print( s )
df[,s] <- GetShadingIndex( df, listCanopy[[i]] )
# Convert the shade into a light value using the formula from Appendix S1 of
# Ruger et al. 2009
df[,l] <- exp(-0.01351 - 0.08043*df[,s] - 0.00315*df[,s]^2)
print( proc.time() - start )
saveRDS( df[,c("tag",s,l)], paste0( growthDataPath, "Shade-light-", names(listCanopy)[i], ".rds" ) )
}
library(nlme)
source( paste( mainSourcePath, "Utilities.R", sep="") )
df <- GetGrowthModelData()  # From Utilities.R
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + pH + l.dbh + l.light + l.slope + convex
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
listRE <- list( "~ l.dbh + l.light + Mn3 + M3P + K3 | sp",
"~ l.dbh + l.light + Mn3 + K3 | sp",
"~ l.dbh + l.light + Mn3 + M3P | sp",
"~ l.dbh + l.light + M3P + K3 | sp",
"~ l.dbh + l.light + Mn3 | sp",
"~ l.dbh + l.light + K3 | sp",
"~ l.dbh + l.light + M3P | sp",
"~ l.dbh + l.light | sp")
# Test each RE structure. REML must be used
listMods <- vector( mode="list", length=length(listRE) )
i = length(listRE)
startTime <- proc.time()
randomEffect <- as.formula( listRE[[i]] )
listMods[[i]] <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="REML", control=modCtrl,
weights=varExp() )
print( paste( "Time for", listRE[[i]], ":" ) )
print( proc.time() - startTime )
library( nlme )
library( car )
source( paste( mainSourcePath, "Utilities.R", sep="") )
df <- GetGrowthModelData()  # From Utilities.R
# The models need to be fitted with ML since the fixed effects
# are being changed in each step of the process
# The "optimal" random effects included the soil vars Mn and P.
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + pH + l.dbh + l.light + l.slope + convex
randomEffect <- ~ l.dbh + l.light + Mn3 + M3P | sp
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + l.dbh + l.light
startTime <- proc.time()
mod.c.reml <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="REML", control=modCtrl,
weights=varExp() )
print( proc.time() - startTime )
summary(mod.c.reml)
# Save the model? If not, comment out
saveRDS( mod.c.reml, paste0( dataPath, "Selected growth model.rds" ) )
write.csv( coef( mod.c.reml ), paste0( dataPath, "BCI growth model Coefs-light,dbh,Mn,P-RE 2010 soil.csv" ) )
library(nlme)
library(MuMIn)
options(na.action = "na.fail")
source( paste0( mainSourcePath, "Utilities.R" ) )
df <- GetGrowthModelData()  # From Utilities.R
# The best random effect structure is found by "Find best model random effects.R"
# Since the "best" RE chosen would not have been the same depending on whether
# the AIC or BIC was used to decide, several different RE structures are tested
# to ascertain any differences based on differing RE structures.
# Model for the model averaging with the "best" RE, and the full fixed effects
fixedEffect <- log(incgr) ~ l.dbh + l.light + Mn3 + M3P + Al3 + K3 + pH + l.slope + convex
randomEffect <- ~ l.dbh + l.light + Mn3 + M3P | sp
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
startTime <- proc.time()
mod.full <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="ML", control=modCtrl,
weights=varExp() )
print( proc.time() - startTime )
startTime <- proc.time()
mods.ldmp.AIC <- dredge( mod.full, subset=l.dbh & l.light & Mn3 & M3P,
beta="none", extra=c(r2.Xu), trace=T )
source( paste0( mainSourcePath, "Legume Growth Analysis.R" ) )
GetModelSoilTopoCorrelations()
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
mainSourcePath
source( paste0( mainSourcePath, "Utilities.R" ) )
mod <- readRDS( paste0( dataPath, "Selected growth model.rds" ) )
df.coef <- coef( mod )
df.aff <- data.frame( sp=row.names( df.coefs ) )
df.aff <- data.frame( sp=row.names( df.coef ) )
df.aff <- cbind( df.aff, df.coef[df.aff$sp,] )
names(mod$data)
print( GetModelSoilTopoCorrelations() )
df.latin <- readRDS( paste0( growthDataPath, "bci_spptable.rds" ) )
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
df.latin <- readRDS( paste0( growthDataPath, "bci_spptable.rds" ) )
names(df.latin)
df.coef <- coef( mod )
df.aff <- data.frame( sp=row.names( df.coef ) )
df.aff <- cbind( df.aff, df.coef[df.aff$sp,] )
df.aff <- merge( df.aff, df.latin[, 1:2], by="sp")
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
if ( !exists("PathsAndEnvironmentInitialised") ) {
if ( !exists("baseRSourcePath") ) {
# Set up the variable baseRSourcePath to the correct path
# e.g.:
# baseRSourcePath <- Sys.getenv("R_USER")
}
source( paste0( baseRSourcePath, "Source/Env.R" ) )
}
# Set up directories to reference the raw and the reformatted and created growth data
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
source( paste0( mainSourcePath, "Utilities.R" ) )
mod <- readRDS( paste0( dataPath, "Selected growth model.rds" ) )
df.latin <- readRDS( paste0( growthDataPath, "bci_spptable.rds" ) )
# The random effects coefficients in this model are for four REs: light, DBH, Mn and P
df.coef <- coef( mod )
df.aff <- data.frame( sp=row.names( df.coef ) )
df.aff <- cbind( df.aff, df.coef[df.aff$sp,] )
df.aff <- merge( df.aff, df.latin[, 1:2], by="sp")
df.aff <- merge( df.aff, GetDistributionAffinities(df.aff$Latin), by.x="Latin", by.y="sp" )
head(df.aff)
names(df.aff[, c(4:6,11:13,16) ])
pairs(df.aff[, c(4:6,12,15,16) ]) # no correlation in affinites
cor(df.aff[, c(4:6,12,15,16) ])
cor(df.aff[, c(4:7,12,15,16) ])
cor(df.aff[, c(4:5,12,15,16) ])
summary(lm( M3P ~ P, data=df.ff))
summary(lm( M3P ~ P, data=df.aff))
.112^2
names(df.aff)
pairs(df.aff[, c("M3P", "P", "Mn3", "Al") ]) # no correlation in affinites
cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])
mod.P <- lm( M3P ~ P, data=df.aff)
plot( mod.P )
summary( mod.P )  # No relationship for P
str(cor(df.aff[, c("M3P", "P", "Mn3", "Al") ]))
cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])["M3P", "P"]
cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])["M3P", "P"]^2
print( paste( "P affinity correlation with P response: ", affCor["M3P", "P"]^2) )  # 0.0126
affCor <- cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])
print( paste( "P affinity correlation with P response: ", affCor["M3P", "P"]^2) )  # 0.0126
print( paste( "P affinity correlation R2 with P response: ", affCor["M3P", "P"]^2) )  # 0.0126
source( paste0( mainSourcePath, "Correlations Analyses.R" ) )
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
library(fgeo.habitat) # the kriging functionality
df.soil <- read.csv( paste0( rawDataPath, "soils.csv" ) )
df.prms <- read.csv( paste0( dataPath, "krige prms.csv" ) )
df.res <- data.frame()
i=1
prm <- df.prms[i,]
prm
prms <- list( model=as.character(prm$model),
kappa=prm$kappa,
nugget=prm$nugget, sill=prm$sill,
range=prm$range )
prms
ks <- fgeo.habitat::GetKrigedSoil( df.soil, var=as.character(prm$var),
krigeParams=prms, gridSize=10 )
df.res <- data.frame()
for ( i in 1:nrow(df.prms) ) {
prm <- df.prms[i,]
prms <- list( model=as.character(prm$model),
kappa=prm$kappa,
nugget=prm$nugget, sill=prm$sill,
range=prm$range )
# Do the kriging. Note that the argument useKsLine=T or F should give the same result
ks <- fgeo.habitat::GetKrigedSoil( df.soil, var=as.character(prm$var),
krigeParams=prms, gridSize=10, useKsLine=F )
# Store the results in a data frame
if ( i == 1 ) {
df.res <- ks$df
} else {
df.res <- cbind( df.res, ks$df[,"z"] )
}
}
names( df.res )[3:ncol(df.res)] <- as.character( df.prms$var )
head(df.res)
write.csv( df.res, file=paste0( dataPath, "kriged soils-10m.csv" ), row.names=T )
write.csv( df.res, file=paste0( dataPath, "kriged soils-10m.csv" ), row.names=F )
library( nlme )
library( car )
source( paste( mainSourcePath, "Utilities.R", sep="") )
df <- GetGrowthModelData()  # From Utilities.R
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + pH + l.dbh + l.light + l.slope + convex
randomEffect <- ~ l.dbh + l.light + Mn3 + M3P | sp
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + l.dbh + l.light
startTime <- proc.time()
mod.c.reml <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="REML", control=modCtrl,
weights=varExp() )
print( proc.time() - startTime )
summary(mod.c.reml)
mod <- readRDS( paste0( dataPath, "Selected growth model.rds" ) )
summary(mod)
dim(df.res)
df.soils <- read.csv(file=paste0( dataPath, "kriged soils-10m.orig.csv" ))
head(df.soils)
df.soils <- df.soils[,names(df.res)]
head(df.soils)
df.soils <- df.soils[ with(df.soils, order(x,y)), ]
df.res <- df.res[ with(df.res, order(x,y)), ]
dim(df.soils)
dim(df.res)
all.equal(df.res, df.soils)
df.prms
i=1
prm <- df.prms[i,]
prms <- list( model=as.character(prm$model),
kappa=prm$kappa,
nugget=prm$nugget, sill=prm$sill,
range=prm$range )
ks <- fgeo.habitat::GetKrigedSoil( df.soil, var=as.character(prm$var),
krigeParams=prms, gridSize=10, useKsLine=T )
df.x <- ks$df; names(df.x)[3] <- prm$var; df.x <- df.x[with(df.x, order(x,y)),]
head(df.x)
df.x <- ks$df; names(df.x)[3] <- as.character(prm$var); df.x <- df.x[with(df.x, order(x,y)),]
head(df.x)
all.equal(df.res[,1:3], df.x)
dim(df.x)
dim(df.res[,1:3])
head(df.res[,1:3])
prms
head(df.soils)
prms$sill=0.086
ks <- fgeo.habitat::GetKrigedSoil( df.soil, var=as.character(prm$var),
krigeParams=prms, gridSize=10, useKsLine=F )
df.x <- ks$df; names(df.x)[3] <- as.character(prm$var); df.x <- df.x[with(df.x, order(x,y)),]
head(df.x)
prms
df.prms
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
# Set up directories to reference the raw and the reformatted and created growth data
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
library(fgeo.habitat) # the kriging functionality
# Get the soil data
df.soil <- read.csv( paste0( rawDataPath, "soils.csv" ) )
# Get the kriging semivariogram parameters
df.prms <- read.csv( paste0( dataPath, "krige prms.csv" ) )
df.res <- data.frame()
for ( i in 1:nrow(df.prms) ) {
prm <- df.prms[i,]
prms <- list( model=as.character(prm$model),
kappa=prm$kappa,
nugget=prm$nugget, sill=prm$sill,
range=prm$range )
# Do the kriging. Note that the argument useKsLine=T or F should give the same result
ks <- fgeo.habitat::GetKrigedSoil( df.soil, var=as.character(prm$var),
krigeParams=prms, gridSize=10, useKsLine=F )
# Store the results in a data frame
if ( i == 1 ) {
df.res <- ks$df
} else {
df.res <- cbind( df.res, ks$df[,"z"] )
}
}
# Set the column names correctly
names( df.res )[3:ncol(df.res)] <- as.character( df.prms$var )
# Save the kriged values
write.csv( df.res, file=paste0( dataPath, "kriged soils-10m.csv" ), row.names=F )
if ( !file.exists( paste0( dataPath, "kriged soils-10m.csv" ) ) ) {
# The kriging functionality resides in a package, managed by ForestGEO.
# Install the package if need be
#install.packages( "devtools" )
#devtools::install_github("forestgeo/fgeo.habitat")
library(fgeo.habitat) # the kriging functionality
# Get the soil data
df.soil <- read.csv( paste0( rawDataPath, "soils.csv" ) )
# Get the kriging semivariogram parameters
df.prms <- read.csv( paste0( dataPath, "krige prms.csv" ) )
df.res <- data.frame()
for ( i in 1:nrow(df.prms) ) {
prm <- df.prms[i,]
prms <- list( model=as.character(prm$model),
kappa=prm$kappa,
nugget=prm$nugget, sill=prm$sill,
range=prm$range )
# Do the kriging. Note that the argument useKsLine=T or F should give the same result
ks <- fgeo.habitat::GetKrigedSoil( df.soil, var=as.character(prm$var),
krigeParams=prms, gridSize=10, useKsLine=F )
# Store the results in a data frame
if ( i == 1 ) {
df.res <- ks$df
} else {
df.res <- cbind( df.res, ks$df[,"z"] )
}
}
# Set the column names correctly
names( df.res )[3:ncol(df.res)] <- as.character( df.prms$var )
# Save the kriged values
write.csv( df.res, file=paste0( dataPath, "kriged soils-10m.csv" ), row.names=F )
}
library( nlme )
library( car )
source( paste( mainSourcePath, "Utilities.R", sep="") )
df <- GetGrowthModelData()  # From Utilities.R
# The models need to be fitted with ML since the fixed effects
# are being changed in each step of the process
# The "optimal" random effects included the soil vars Mn and P.
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + pH + l.dbh + l.light + l.slope + convex
randomEffect <- ~ l.dbh + l.light + Mn3 + M3P | sp
modCtrl <- lmeControl( maxIter=150, msMaxIter=150, niterEM=50, msMaxEval=250 )
fixedEffect <- log(incgr) ~ Mn3 + M3P + K3 + Al3 + l.dbh + l.light
startTime <- proc.time()
mod.c.reml <- lme( fixed=fixedEffect, random=randomEffect,
data=df, method="REML", control=modCtrl,
weights=varExp() )
print( proc.time() - startTime )
summary(mod.c.reml)
head(coef( mod.c.reml ))
mod = readRDS( paste0( dataPath, "Selected growth model.rds" ) )
summary(mod)
df.coef<- read.csv(paste0( dataPath, "BCI growth model Coefs-light,dbh,Mn,P-RE 2010 soil.csv" ) )
all.equal(df.coef, coef(mod.c.reml) )
names(df.coef)
dim(df.coef)
dim(coef(mod.c.reml))
head(coef(mod.c.reml))
all.equal(df.coef[,2:8], coef(mod.c.reml) )
write.csv( coef( mod.c.reml ), paste0( dataPath, "BCI growth model Coefs.csv" ) )
source( paste0( mainSourcePath, "Utilities.R" ) )
df.coef <- read.csv( paste0( dataPath, "BCI growth model Coefs.csv" ) )
head(df.coef)
df.coef <- coef( mod.c.reml )
names( df.coef )[1:2] <- c( "sp", "Intercept" )
write.csv( coef( mod.c.reml ), paste0( dataPath, "BCI growth model Coefs.csv" ) )
df.coef <- read.csv( paste0( dataPath, "BCI growth model Coefs.csv" ) )
head(df.coef)
df.coef <- coef( mod.c.reml )
names( df.coef )[1:2] <- c( "sp", "Intercept" )
write.csv( df.coef, paste0( dataPath, "BCI growth model Coefs.csv" ) )
df.coef <- read.csv( paste0( dataPath, "BCI growth model Coefs.csv" ) )
head(df.coef)
df.coef <- coef( mod.c.reml )
c("sp", names(df.coef))
write.csv( df.coef, paste0( dataPath, "BCI growth model Coefs.csv" ),
col.names = c("sp", names(df.coef)) )
write.csv( df.coef, paste0( dataPath, "BCI growth model Coefs.csv" ),
row.names = T, col.names = c("sp", names(df.coef)) )
c("sp", names(df.coef))
df.coef <- cbind( data.frame( sp=row.names(coef( mod.c.reml ) ), coef( mod.c.reml ) )
write.csv( df.coef, paste0( dataPath, "BCI growth model Coefs.csv" ),
row.names = F )
df.coef <- cbind( data.frame( sp=row.names(coef( mod.c.reml )) ), coef( mod.c.reml ) )
head(df.coef)
write.csv( df.coef, paste0( dataPath, "BCI growth model Coefs.csv" ), row.names = F )
df.coef <- read.csv( paste0( dataPath, "BCI growth model Coefs.csv" ) )
head( df.coef)
df.latin <- readRDS( paste0( growthDataPath, "bci_spptable.rds" ) )
df.aff <- merge( df.coef, df.latin[, 1:2], by="sp")
df.aff <- merge( df.aff, GetDistributionAffinities(df.aff$Latin), by.x="Latin", by.y="sp" )
dim(df.aff)
affCor <- cor(df.aff[, c("M3P", "P", "Mn3", "Al") ])
print( paste( "P affinity correlation R2 with P response: ", affCor["M3P", "P"]^2) )  # 0.0126
mod.P <- lm( M3P ~ P, data=df.aff)
summary( mod.P )  # No relationship for P, p = 0.11, adjusted R2 0.0076, multiple R2 as above
print( GetModelSoilTopoCorrelations() )
source( paste0( mainSourcePath, "BCI legumes.R" ) )
df.coef <- read.csv( paste0( dataPath, "BCI growth model Coefs.csv" ) )
df.legumes <- df.coef[ df.coef$sp %in% GetBCILegumes(), ]
df.nonlegumes <- df.coef[ !(df.coef$sp %in% GetBCILegumes()), ]
df.coef$legume <- F
df.coef[ df.coef$sp %in% GetBCILegumes(), "legume" ] <- T
head(df.coef)
dim(df.legumes)
dim(df.nonlegumes)
dim(df.coef)
mod.Mn <- gls( Mn3 ~ legume, data=df.coef )
mod.Mn.gls <- gls( Mn3 ~ legume, data=df.coef, weights = varExp() )
mod.Mn.gls.2 <- gls( Mn3 ~ legume, data=df.coef, weights = varPower(2) )
AIC( mod.Mn, mod.Mn.gls, mod.Mn.gls.2 ) # varExp or varPower is better
anova(mod.Mn.gls)
mod.P <- gls( M3P ~ legume, data=df.coef )
mod.P.gls <- gls( M3P ~ legume, data=df.coef, weights = varExp() )
AIC( mod.P, mod.P.gls ) # varExp is better
anova(mod.P.gls)
print( summary(mod.P.gls) ) # p = 0.24
print( summary(mod.Mn.gls) ) # Legumes more negative by -0.011 (p=0.004)
mod.light <- gls( l.light ~ legume, data=df.coef )
mod.light.gls <- gls( l.light ~ legume, data=df.coef, weights = varExp() )
AIC( mod.light, mod.light.gls )
summary( mod.light.gls ) # p = 0.7854
mod.dbh <- gls( l.dbh ~ legume, data=df.coef )
mod.dbh.gls <- gls( l.dbh ~ legume, data=df.coef, weights = varExp() )
AIC( mod.dbh, mod.dbh.gls )
summary( mod.dbh.gls ) # p = 0.1082
GetBCILegumes()
bciLegumes <- GetBCILegumes()
df.legumes <- df.coef[ df.coef$sp %in% bciLegumes, ]
df.nonlegumes <- df.coef[ !(df.coef$sp %in% bciLegumes), ]
df.coef$legume <- F
df.coef[ df.coef$sp %in% bciLegumes, "legume" ] <- T
dim(df.coef)
head(df.coef)
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
source( paste0( mainSourcePath, "Utilities.R" ) )
if (Sys.getenv("R_USER") == "") {
basePath <- "~"   # The typical R base path on Unix/Mac systems
} else {
basePath <- Sys.getenv("R_USER")  # Windows
}
# This path needs to be set to the correct path
baseRSourcePath <- paste0( basePath, "/R/Github/Soil-drivers-of-tree-growth/" )
source( paste0( baseRSourcePath, "Source/Env.R" ) )
source( paste0( mainSourcePath, "packages.R" ) )
growthDataPath <- paste0( dataPath, "Growth Data/" )
rawDataPath <- paste0( dataPath, "Raw Data/" )
source( paste0( mainSourcePath, "Utilities.R" ) )
df.soil <- read.csv( paste0( rawDataPath, "soils.csv" ) )
# Get the kriging semivariogram parameters
df.prms <- read.csv( paste0( dataPath, "krige prms.csv" ) )
df.res <- data.frame()
for ( i in 1:nrow(df.prms) ) {
prm <- df.prms[i,]
prms <- list( model=as.character(prm$model),
kappa=prm$kappa,
nugget=prm$nugget, sill=prm$sill,
range=prm$range )
# Do the kriging. Note that the argument useKsLine=T or F should give the same result
ks <- fgeo.habitat::GetKrigedSoil( df.soil, var=as.character(prm$var),
krigeParams=prms, gridSize=10, useKsLine=F )
# Store the results in a data frame
if ( i == 1 ) {
df.res <- ks$df
} else {
df.res <- cbind( df.res, ks$df[,"z"] )
}
}
# Set the column names correctly
names( df.res )[3:ncol(df.res)] <- as.character( df.prms$var )
# Save the kriged values
write.csv( df.res, file=paste0( dataPath, "kriged soils-10m.csv" ), row.names=F )
print( GetModelSoilTopoCorrelations() )
